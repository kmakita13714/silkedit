'use strict';

const fs = require('fs')
const path = require('path')
const domain = require('domain');
const bridge = process.binding('silkeditbridge');
const check = require('syntax-error');

const PACKAGES_BEGIN_INDEX = 3;
const packageRootPaths = process.argv.slice(PACKAGES_BEGIN_INDEX);
const loadedPackages = {};
 
module.exports = function(CommandManager, tr) {
  
function checkOS(pkg) {
  return pkg.os == null || (Object.prototype.toString.call(pkg.os) === '[object Array]' && pkg.os.indexOf(process.platform) != -1);
}

function installDependencies(fn, dirPath, rootObj, dependencies) {
  if (dependencies in rootObj) {
    Object.keys(rootObj[dependencies]).forEach((name) => {
      fs.readFile(path.join(dirPath, 'node_modules', name, 'package.json'), 'utf-8', (err, data) => {
        if (err) {
          console.error(err);
          return;
        }

        const pkg = JSON.parse(data);
        if (checkOS(pkg)) {
          fn(path.join(dirPath, 'node_modules', name));
        };
      });
    });
  }
}

function callForeachPackageDir(fn) {
  // Pass default package first
  fn(path.join(__dirname, '..', 'node_modules', 'default'));
  
  packageRootPaths.forEach((dirPath) => {
    fs.open(dirPath, 'r', (err, fd) => {
      // load each package in node_modules
      fd && fs.close(fd, (err) => {
        // find root package.json
        fs.readFile(path.join(dirPath, 'package.json'), 'utf-8', (err, data) => {
          if (err) {
            console.error(err);
            return;
          }
          
          const d = domain.create();
          d.on('error', function(er) {
            console.error(er.stack);
          });
          d.run(function() {
            const rootObj = JSON.parse(data);
            ['dependencies', 'optionalDependencies'].forEach((dep) => installDependencies(fn, dirPath, rootObj, dep));
          })
        })
      })
    })
  })  
}

function loadPackage(dir) {
  var pjson, doc, module

  fs.readdir(dir, (err, files) => {
    if (err) {
      console.warn(err.message);
      return;
    }

    const packageJsonPath = path.join(dir, "package.json");
    // check if packageJsonPath exists by opening it. fs.exists is deprecated.
    fs.open(packageJsonPath, 'r', (err, fd) => {
      fd && fs.close(fd, (err) => {
        // clear require cache to reload a package
        delete require.cache[require.resolve(packageJsonPath)]
        pjson = require(packageJsonPath);
        if (pjson.name == null) {
          console.warn('missing package name');
          return;
        }
        
        if (!checkOS(pjson)) {
          return;
        }

        // cache a package directory path
        loadedPackages[pjson.name] = {name: pjson.name, dir: dir};
         
        // load keymap
        const keymapPath = path.join(dir, "keymap.yml");
        fs.open(keymapPath, 'r', (err, fd) => {
          fd && fs.close(fd, (err) => {
            bridge.KeymapManager.load(keymapPath, pjson.name);
          })
        })

        // load menu
        const menuFilePath = path.join(dir, "menu.yml");
        fs.open(menuFilePath, 'r', (err, fd) => {
          fd && fs.close(fd, (err) => {
            bridge.Window.loadMenu(pjson.name, menuFilePath);
          })
        })

        // load config definition
        const configDefPath = path.join(dir, "config_definition.yml")
        fs.open(configDefPath, 'r', (err, fd) => {
          if (fd) {
            try {
              if (pjson.name != 'default') {
                bridge.ConfigDialog.loadDefinition(pjson.name, configDefPath)
              }
            } catch(e) {
              console.warn(e)
            } finally {
              fs.close(fd)
            }
          }

          // register commands
          if (pjson.main) {
            try {
              delete require.cache[require.resolve(dir)]
              module = require(dir)
              loadedPackages[pjson.name].module = module;
            } catch(e) {
              // e is SyntaxError but it doesn't have information about file, line number, etc.
              // try to show a friendly error as Node using syntax-error
              const file = require.resolve(dir);
              const src = fs.readFileSync(file);
              const err = check(src, file);
              if (err) {
                console.warn(err);
              } else {
                console.warn(e.stack)
              }
              return
            }
            if (module.commands) {
              if (pjson.name === 'default') {
                // don't add a package prefix for default package
                Object.keys(module.commands).forEach((cmd) => {
                  CommandManager.add(cmd, tr("command." + cmd + ".description", 'default'), module.commands[cmd]);
                });
              } else {
                Object.keys(module.commands).forEach((cmd) => {
                  CommandManager.add(pjson.name + '.' + cmd, tr("command." + cmd + ".description", pjson.name), module.commands[cmd]);
                });
              }
            } else {
              console.log("no commands")
            }

            // call module's activate method
            if (module.activate) {
              module.activate()
            }
          }
        })
      })
    })
  })
}

function unloadPackage(name) {
  if (name in loadedPackages && 'module' in loadedPackages[name]) {
    const module = loadedPackages[name].module;

    if (module.commands) {
      if (name === 'default') {
        // don't add a package prefix for default package
        Object.keys(module.commands).forEach(cmd => CommandManager.remove(cmd));
      } else {
        Object.keys(module.commands).map(c => name + '.' + c).forEach(cmd => CommandManager.remove(cmd));
      }
      bridge.KeymapManager.unload(name);
    }

    // call module's deactivate method
    if (module.deactivate) {
      module.deactivate()
    }
  }
}

function deactivatePackages() {
  for (let name in loadedPackages) {
    const pkg = loadedPackages[name];
    if ('module' in pkg && 'deactivate' in pkg.module) {
      pkg.module.deactivate();
    }
  }
}

/**
 * @typedef Package
 * @type {object}
 * @memberof module:silkedit
 * @property {string} name - パッケージ名
 * @property {string} dir - パッケージの存在するディレクトリ
 */

  /**
   * パッケージを扱うオブジェクト。
   * @namespace
   * @memberof module:silkedit
   */
  const PackageManager = {
    /**
     * @function
     * @param {string} name - パッケージ名
     * @returns {boolean}
     */
    isLoaded: (name) => {
      return name in loadedPackages;
    },
    
    /**
     * @function
     * @param {string} dir - パッケージの存在するディレクトリ
     */
    loadPackage: loadPackage,
    
    /**
     * @function
     * @param {string} name - パッケージ名
     */
    unloadPackage: unloadPackage,
    
    /**
     * @function
     */
    reloadPackages: () => {
      for (const name in loadedPackages) {
        unloadPackage(name);
      }
      bridge.clearTranslationCache();

      bridge.PackageManager._loadAllPackageContents();
      callForeachPackageDir(loadPackage);
    },
    
    /**
     * @function
     * @returns {module:silkedit.Package[]}
     */
    getPackages: () => {
      const values = [];
      for (const name in loadedPackages) {
        values.push(loadedPackages[name])
      }
      return values;
    },

    /**
     * @function
     * @param {string} name - パッケージ名
     * @returns {module:silkedit.Package}
     */
    getPackage: (name) => {
      return name in loadedPackages ? loadedPackages[name] : null;
    },
    
    // internal
    _deactivatePackages: deactivatePackages,
    
    _ensureRootPackageJson: () => {
      bridge.PackageManager._ensureRootPackageJson();
    }
  };

  return PackageManager;
}