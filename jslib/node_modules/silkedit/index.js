'use strict'

const fs = require('fs')
const yaml = require('js-yaml')
const https = require('https')
const path = require('path')
const bridge = process.binding('silkeditbridge')
const QtEventEmitter = require('./core/qt_event_emitter')(bridge);
const domain = require('domain');
const util = require('util');

const locale = process.argv[2];
const packagesBeginIndex = 3
var commands = {}
var eventFilters = {}
var configs = {}
var packageRootPaths = []
var packageDirMap = {}

function getDirs(dir) {
  const files = fs.readdirSync(dir)
  var dirs = []

  files.forEach((file) => {
    const stat = fs.statSync(path.join(dir, file));
    if (stat.isDirectory()) {
      dirs.push(file);
    }
  });

  return dirs;
}

function callForeachPackageDir(fn) {
  packageRootPaths.forEach((dirPath) => {
    fs.open(dirPath, 'r', (err, fd) => {
      // load each package in node_modules
      fd && fs.close(fd, (err) => {
        // find packages.json
        fs.readFile(path.join(dirPath, 'packages.json'), 'utf-8', (err, data) => {
          if (err) {
            return;
          }
          
          const d = domain.create();
          d.on('error', function(er) {
            console.error(er.stack);
          });
          d.run(function() {
            JSON.parse(data).forEach((pkg) => {
              fn(path.join(dirPath, 'node_modules', pkg.name))
            })
          })
        })
      })
    })
  })  
}

bridge.JSHandler.commandEvent = (cmd, args) => {
    var event = {
      "cmd": cmd,
      "args": args
    }
    const type = "command"
    if (type in eventFilters) {
      eventFilters[type].forEach(fn => fn(event))
    }
  };

bridge.JSHandler.focusChanged = (viewType) => {
    var event = {
      "type": viewType
    }
    const type = "focusChanged"
    if (type in eventFilters) {
      eventFilters[type].forEach(fn => fn(event))
    }
  };

bridge.JSHandler.loadPackage = loadPackage;

bridge.JSHandler.reloadKeymaps = () => {
    
    const loadKeymap = (dir) => {
      var pjson, configPath, doc, module

      fs.readdir(dir, (err, files) => {
        if (err) {
          console.warn(err.message);
          return;
        }

        const packageJsonPath = path.join(dir, "package.json");
        // check if packageJsonPath exists by opening it. fs.exists is deprecated.
        fs.open(packageJsonPath, 'r', (err, fd) => {
          fd && fs.close(fd, (err) => {
            pjson = require(packageJsonPath);
            if (pjson.name == null) {
              console.warn('missing package name')
              return
            }
         
            // load keymap
            const keymapPath = path.join(dir, "keymap.yml");
            fs.open(keymapPath, 'r', (err, fd) => {
              fd && fs.close(fd, (err) => {
                loadKeymap(pjson.name, keymapPath);
              })
            })
          })
        })
      })
    }
    
    callForeachPackageDir(loadKeymap)
  };

bridge.JSHandler.runCommand = (cmd, args) => {
    if (cmd in commands) {
      const d = domain.create();
      d.on('error', function(er) {
        console.error(er.stack);
      });
      d.run(function() {
        commands[cmd](args);
      })
    } else {
      console.warn(cmd + 'not found');
    }
  };

bridge.JSHandler.eventFilter = (type, event, response) => {
    // console.log('eventFilter. type: %s', type)
    if (type in eventFilters) {
        try {
          response.result(eventFilters[type].some(fn => { return fn(event)}))
        } catch (err) {
          console.error(err)
          response.result(false)
        }
    } else {
      response.result(false)
    }
  }

bridge.JSHandler.keyEventFilter = (type, key, repeat, altKey, ctrlKey, metaKey, shiftKey) => {
    console.log('keyEventFilter. type: %s, key: %s, repeat: %s, altKey: %s, ctrlKey: %s, metaKey: %s, shiftKey: %s', type, key, repeat, altKey, ctrlKey, metaKey, shiftKey)
    var event = {
      "type": type
      ,"key": key
      ,"repeat": repeat
      ,"altKey": altKey
      ,"ctrlKey": ctrlKey
      ,"metaKey": metaKey
      ,"shiftKey": shiftKey
    }
    if (type in eventFilters) {
        try {
          return eventFilters[type].some(fn => fn(event));
        } catch (err) {
          console.error(err);
          return false;
        }
    } else {
      return false;
    }
  };
    
bridge.JSHandler.cmdEventFilter = (name, args) => {
    var event = {
      "name": name,
      "args": args
    }
    const type = "runCommand"
    if (type in eventFilters) {
        try {
          const result = eventFilters[type].some(fn => { return fn(event)})
          return [result, event.name, event.args]
        } catch (err) {
          console.error(err)
          return [false, event.name, event.args]
        }
    } else {
      return [false, event.name, event.args]
    }
  };

bridge.JSHandler.translate = t;

bridge.JSHandler.removePackage = (dir, response) => {
    var pjson, module;
  
    const packageJsonPath = path.join(dir, "package.json");
    fs.open(packageJsonPath, 'r', (err, fd) => {
      if (err) {
        console.log(dir + ' is already deleted')
        response.setResult(true)
        return
      }
      
      fd && fs.close(fd, (err) => {
        pjson = require(packageJsonPath);
        // unregister commands
        if (pjson && pjson.main) {
          try {
            module = require(dir)
            if (module.commands) {
              if (pjson.name === 'default') {
                // don't add a package prefix for default package
                for (var prop in module.commands) {
                  delete commands[prop]
                }
                Object.keys(module.commands).forEach(cmd => bridge.CommandManager.remove(cmd));
              } else {
                for (var prop in module.commands) {
                  delete commands[pjson.name + '.' + prop]
                }
                Object.keys(module.commands).map(c => pjson.name + '.' + c).forEach(cmd => bridge.CommandManager.remove(cmd));
              }
            } else {
              console.log("no commands")
            }

            // call module's deactivate method
            if (module.deactivate) {
              module.deactivate()
            }
            response.setResult(true)
          } catch(e) {
            console.warn(e)
            response.setResult(false)
          }
        }
      })
    })
  };
  
bridge.JSHandler.sendGetRequest = (url, timeoutInMS, response) => {
    const req = https.get(url, function(res) {
      var body = '';
      res.setEncoding('utf8');
 
      res.on('data', function(chunk){
        body += chunk;
      });
 
      res.on('end', function(res){
        response.onSucceeded(body)
      });
    });
    req.setTimeout(timeoutInMS);
    req.on('timeout', function() {
      response.onFailed('timeout');
      req.abort();
    });
    req.on('error', function(e) {
      response.onFailed(e.message);
    });
  };
  
bridge.JSHandler.inheritsQtEventEmitter = (proto) => {
  switch(typeof proto) {
    case 'function':
      util.inherits(proto, QtEventEmitter);
      break;
    case 'object':
      Object.setPrototypeOf(proto, QtEventEmitter.prototype);
      break;
    default:
      console.error('invalid proto');
  }
}

// init after JSHandler is initialized to call inheritsQtEventEmitter
bridge.lateInit(bridge);
  
packageRootPaths = process.argv.slice(packagesBeginIndex);
callForeachPackageDir(loadPackage)

  // private utility functions

  function convert(value, name, defaultValue, convertFn) {
    // console.log('value: %s', value)
    if (value != null && convertFn != null) {
      return convertFn(value)
    } else {
      return 'default' in configs[name] ? configs[name].default : defaultValue
    }
  }

// These functions are defined here because this is used by other API.

// translate
function t(key, defaultValue) {
  var i, j, packageName, currentObj, fd, translationPaths;
  try {
    // get package name from '<package>:key'
    const semicolonIndex = key.indexOf(':')
    if (semicolonIndex > 0) {
      packageName = key.substring(0, semicolonIndex)
    } else {
      // use 'default' if the package name is missing
      packageName = 'default'
    }

    if (packageName in packageDirMap) {
      translationPaths = []
      translationPaths.push(path.normalize(packageDirMap[packageName] + '/locales/' + locale + "/translation.yml"))
      const indexOf_ = locale.indexOf('_')
      if (indexOf_ > 0) {
        translationPaths.push(path.normalize(packageDirMap[packageName] + '/locales/' + locale.substring(0, indexOf_) + "/translation.yml"))
      }
      for (i = 0; i < translationPaths.length; i++) {
        try {
          fd = fs.openSync(translationPaths[i], 'r')
        } catch(e) {
          // translation file doesn't exist
          if (e.code === 'ENOENT') {
            continue;
          }
          throw e
        }
        if (fd != null) {
          try {
            // get value for the matching key
            const doc = yaml.safeLoad(fs.readFileSync(translationPaths[i], 'utf8'))
            const subKeys = key.substring(semicolonIndex + 1).split('.')
            currentObj = doc
            for (j = 0; j < subKeys.length; j++) {
              if (subKeys[j] in currentObj) {
                currentObj = currentObj[subKeys[j]]
              } else {
                currentObj = null
                break
              }
            }

            if (currentObj != null) {
              return currentObj
            }
          } finally {
            fs.close(fd)
          }
        }
      }
    }
  } catch(e) {
    console.warn(e)
  }

  return defaultValue ? defaultValue : ""
}

function loadPackage(dir) {
  var pjson, doc, module

  fs.readdir(dir, (err, files) => {
    if (err) {
      console.warn(err.message);
      return;
    }

    const packageJsonPath = path.join(dir, "package.json");
    //console.log(packageJsonPath);
    // check if packageJsonPath exists by opening it. fs.exists is deprecated.
    fs.open(packageJsonPath, 'r', (err, fd) => {
      fd && fs.close(fd, (err) => {
        pjson = require(packageJsonPath);
        if (pjson.name == null) {
          console.warn('missing package name')
          return
        }

        // cache a package directory path
        packageDirMap[pjson.name] = dir
         
        // load keymap
        const keymapPath = path.join(dir, "keymap.yml");
        fs.open(keymapPath, 'r', (err, fd) => {
          fd && fs.close(fd, (err) => {
            bridge.KeymapManager.load(keymapPath, pjson.name);
          })
        })

        // load menu
        const menuFilePath = path.join(dir, "menu.yml");
        fs.open(menuFilePath, 'r', (err, fd) => {
          fd && fs.close(fd, (err) => {
            bridge.Window.loadMenu(pjson.name, menuFilePath);
          })
        })
          
        // load toolbar
        const toolbarFilePath = path.join(dir, "toolbar.yml");
        fs.open(toolbarFilePath, 'r', (err, fd) => {
          fd && fs.close(fd, (err) => {
            bridge.Window.loadToolbar(pjson.name, toolbarFilePath);
          })
        })

        // load config definition
        const configDefPath = path.join(dir, "config_definition.yml")
        fs.open(configDefPath, 'r', (err, fd) => {
          if (fd) {
            try {
              if (pjson.name != 'default') {
                bridge.ConfigDialog.loadDefinition(pjson.name, configDefPath)
              }
              doc = yaml.safeLoad(fs.readFileSync(configDefPath, 'utf8'))
              // console.log(doc)
              if ('config' in doc) {
                Object.keys(doc.config).forEach(c => {
                  var configName
                  // don't prepend package name for default package
                  if (pjson.name != 'default') {
                    configName = pjson.name + '.' + c
                  } else {
                    configName = c
                  }
                  configs[configName] = doc.config[c]
                })
              }
            } catch(e) {
              console.warn(e)
            } finally {
              fs.close(fd)
            }
          }

          // register commands
          if (pjson.main) {
            try {
              module = require(dir)
            } catch(e) {
              console.warn(e)
              return
            }
            if (module.commands) {
              if (pjson.name === 'default') {
                // don't add a package prefix for default package
                for (var prop in module.commands) {
                  if (typeof(prop) === 'string') {
                    commands[prop] = module.commands[prop];
                  } else if (Array.isArray(prop) && prop.length == 2 && typeof(prop[0]) == 'string') {
                    commands[prop[0]] = module.commands[prop];
                  }
                }
                Object.keys(module.commands).forEach((cmd) => {
                  bridge.CommandManager.add(cmd, t("command." + cmd + ".description"));
                });
              } else {
                for (var prop in module.commands) {
                  commands[pjson.name + '.' + prop] = module.commands[prop];
                }
                Object.keys(module.commands).forEach((cmd) => {
                  bridge.CommandManager.add(pjson.name + '.' + cmd, t(pjson.name + ":command." + cmd + ".description"));
                });
              }
            } else {
              console.log("no commands")
            }

            // call module's activate method
            if (module.activate) {
              module.activate()
            }
          }
        })
      })
    })
  })
}


// add js functions to KeymapManager
const customKeymapManager = bridge.KeymapManager;
customKeymapManager.dispatch = (keyEvent) => {
  if (keyEvent != null) {
    bridge.KeymapManager._dispatchFromJS(keyEvent.type, keyEvent.key, keyEvent.repeat, keyEvent.altKey, keyEvent.ctrlKey, keyEvent.metaKey, keyEvent.shiftKey)
  }
}

// rename QFlags name to enum name (it's impossible to do this in Qt)
const customDialogButtonBox = bridge.DialogButtonBox;
customDialogButtonBox.StandardButton = customDialogButtonBox.StandardButtons;
delete customDialogButtonBox.StandardButtons;

const silkedit = {
    alert: (msg) => {
      const msgBox = new bridge.MessageBox;
      msgBox.text = msg;
      msgBox.exec();
    },

    API: bridge.API,

    loadPackage: loadPackage,

    installEventFilter: (type, fn) => {
      if (type in eventFilters) {
        eventFilters[type].push(fn)
      } else {
        eventFilters[type] = [fn]
      }
    },

    removeEventFilter: (type, fn) => {
      if (type in eventFilters) {
        const index = eventFilters[type].indexOf(fn)
        if (index !== -1) {
          eventFilters[type].splice(index, 1)
        }
      }
    },

    setFont: (family, size) => {
      family = family == null ? '' : family
      size = size == null ? 0 : size
      bridge.API.setFont(family, size)
    },
    t: t,
    Config:  {
      get: (name) => {
        if (name in configs) {
          const value = bridge.Config.value(name)
          const type = configs[name].type
          switch(type) {
            case 'bool':
            case 'boolean':
              return convert(value, name, false, (v) => v === 'true')
            case 'string':
              return convert(value, name, null, (v) => v)
            case 'int':
            case 'integer':
              return convert(value, name, 0, (v) => parseInt(v, 10))
            case 'float':
              return convert(value, name, 0, (v) => parseFloat(v))
            default:
              return null
          }
        } else {
          return null
        }
      }
    },
    // classes
    App: bridge.App,
    CommandManager: bridge.CommandManager,
    Condition: bridge.Condition,
    ConditionManager: bridge.ConditionManager,
    Constants: bridge.Constants,
    Dialog: bridge.Dialog,
    DialogButtonBox: customDialogButtonBox,
    DocumentManager: bridge.DocumentManager,
    FileDialog: bridge.FileDialog,
    KeymapManager: customKeymapManager,
    Label: bridge.Label,
    LineEdit: bridge.LineEdit,
    MessageBox: bridge.MessageBox,
    ProjectManager: bridge.ProjectManager,
    VBoxLayout: bridge.VBoxLayout,

    // enums
    Orientation: bridge.Orientation
};


silkedit.InputDialog = require('./views/input_dialog')(silkedit);

module.exports = silkedit;