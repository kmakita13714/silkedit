'use strict'

const fs = require('fs')
const yaml = require('js-yaml')
const https = require('https')
const path = require('path')
const bridge = process.binding('silkeditbridge');
const QtEventEmitter = require('./lib/qt_event_emitter')(bridge);
const domain = require('domain');
const util = require('util');

const locale = process.argv[2];
const PACKAGES_BEGIN_INDEX = 3
var commands = {}
var packageRootPaths = []
var packageDirMap = {}

// wrap Node.js console object methods
console.log = function() {
  bridge.info(util.format.apply(this, arguments));
}
console.info = console.log;
console.warn = function() {
  bridge.warn(util.format.apply(this, arguments));
}
console.error = function() {
  bridge.error(util.format.apply(this, arguments));
}

function getDirs(dir) {
  const files = fs.readdirSync(dir)
  var dirs = []

  files.forEach((file) => {
    const stat = fs.statSync(path.join(dir, file));
    if (stat.isDirectory()) {
      dirs.push(file);
    }
  });

  return dirs;
}

function checkOS(pkg) {
  return pkg.os == null || (Object.prototype.toString.call(pkg.os) === '[object Array]' && pkg.os.indexOf(process.platform) != -1);
}

function installDependencies(fn, dirPath, rootObj, dependencies) {
  if (dependencies in rootObj) {
    Object.keys(rootObj[dependencies]).forEach((name) => {
      fs.readFile(path.join(dirPath, 'node_modules', name, 'package.json'), 'utf-8', (err, data) => {
        if (err) {
          console.error(err);
          return;
        }

        const pkg = JSON.parse(data);
        if (checkOS(pkg)) {
          fn(path.join(dirPath, 'node_modules', name));
        };
      });
    });
  }
}

function callForeachPackageDir(fn) {
  // Pass default package first
  fn(path.join(__dirname, 'node_modules', 'default'));
  
  packageRootPaths.forEach((dirPath) => {
    fs.open(dirPath, 'r', (err, fd) => {
      // load each package in node_modules
      fd && fs.close(fd, (err) => {
        // find root package.json
        fs.readFile(path.join(dirPath, 'package.json'), 'utf-8', (err, data) => {
          if (err) {
            console.error(err);
            return;
          }
          
          const d = domain.create();
          d.on('error', function(er) {
            console.error(er.stack);
          });
          d.run(function() {
            const rootObj = JSON.parse(data);
            ['dependencies', 'optionalDependencies'].forEach((dep) => installDependencies(fn, dirPath, rootObj, dep));
          })
        })
      })
    })
  })  
}

bridge.JSHandler.loadPackage = loadPackage;

bridge.JSHandler.reloadKeymaps = () => {
    
    const loadKeymap = (dir) => {
      var pjson, configPath, doc, module

      fs.readdir(dir, (err, files) => {
        if (err) {
          console.warn(err.message);
          return;
        }

        const packageJsonPath = path.join(dir, "package.json");
        // check if packageJsonPath exists by opening it. fs.exists is deprecated.
        fs.open(packageJsonPath, 'r', (err, fd) => {
          fd && fs.close(fd, (err) => {
            pjson = require(packageJsonPath);
            if (pjson.name == null) {
              console.warn('missing package name')
              return
            }
         
            // load keymap
            const keymapPath = path.join(dir, "keymap.yml");
            fs.open(keymapPath, 'r', (err, fd) => {
              fd && fs.close(fd, (err) => {
                bridge.KeymapManager.load(keymapPath, pjson.name);
              })
            })
          })
        })
      })
    }
    
    callForeachPackageDir(loadKeymap)
  };

bridge.JSHandler.runCommand = (cmd, args) => {
    if (cmd in commands) {
      const d = domain.create();
      d.on('error', function(er) {
        console.error(er.stack);
      });
      d.run(function() {
        commands[cmd](args);
      })
    } else {
      console.warn(cmd + 'not found');
    }
  };

bridge.JSHandler.translate = tr;

bridge.JSHandler.removePackage = (dir, response) => {
    var pjson, module;
  
    const packageJsonPath = path.join(dir, "package.json");
    fs.open(packageJsonPath, 'r', (err, fd) => {
      if (err) {
        console.log(dir + ' is already deleted')
        response.setResult(true)
        return
      }
      
      fd && fs.close(fd, (err) => {
        pjson = require(packageJsonPath);
        // unregister commands
        if (pjson && pjson.main) {
          try {
            module = require(dir)
            if (module.commands) {
              if (pjson.name === 'default') {
                // don't add a package prefix for default package
                for (var prop in module.commands) {
                  delete commands[prop]
                }
                Object.keys(module.commands).forEach(cmd => bridge.CommandManager.remove(cmd));
              } else {
                for (var prop in module.commands) {
                  delete commands[pjson.name + '.' + prop]
                }
                Object.keys(module.commands).map(c => pjson.name + '.' + c).forEach(cmd => bridge.CommandManager.remove(cmd));
              }
            } else {
              console.log("no commands")
            }

            // call module's deactivate method
            if (module.deactivate) {
              module.deactivate()
            }
            response.setResult(true)
          } catch(e) {
            console.warn(e)
            response.setResult(false)
          }
        }
      })
    })
  };
  
bridge.JSHandler.sendGetRequest = (url, timeoutInMS, response) => {
    const req = https.get(url, function(res) {
      var body = '';
      res.setEncoding('utf8');
 
      res.on('data', function(chunk){
        body += chunk;
      });
 
      res.on('end', function(res){
        response.emit('succeeded', body)
      });
    });
    req.setTimeout(timeoutInMS);
    req.on('timeout', function() {
      response.emit('failed', 'timeout');
      req.abort();
    });
    req.on('error', function(e) {
      response.emit('failed', e.message);
    });
  };
  
bridge.JSHandler.inheritsQtEventEmitter = (proto) => {
  switch(typeof proto) {
    case 'function':
      util.inherits(proto, QtEventEmitter);
      break;
    case 'object':
      Object.setPrototypeOf(proto, QtEventEmitter.prototype);
      break;
    default:
      console.error('invalid proto');
  }
}

bridge.JSHandler.eval = require('./lib/repl').eval;

// init after JSHandler is initialized to call inheritsQtEventEmitter
bridge.lateInit(bridge);
  
packageRootPaths = process.argv.slice(PACKAGES_BEGIN_INDEX);
callForeachPackageDir(loadPackage)

// These functions are defined here because this is used by other API.

function tr(key, defaultValue) {
  var i, j, packageName, currentObj, fd, translationPaths;
  try {
    // get package name from '<package>:key'
    const semicolonIndex = key.indexOf(':')
    if (semicolonIndex > 0) {
      packageName = key.substring(0, semicolonIndex)
    } else {
      // use 'default' if the package name is missing
      packageName = 'default'
    }

    if (packageName in packageDirMap) {
      translationPaths = []
      translationPaths.push(path.normalize(packageDirMap[packageName] + '/locales/' + locale + "/translation.yml"))
      const indexOf_ = locale.indexOf('_')
      if (indexOf_ > 0) {
        translationPaths.push(path.normalize(packageDirMap[packageName] + '/locales/' + locale.substring(0, indexOf_) + "/translation.yml"))
      }
      for (i = 0; i < translationPaths.length; i++) {
        try {
          fd = fs.openSync(translationPaths[i], 'r')
        } catch(e) {
          // translation file doesn't exist
          if (e.code === 'ENOENT') {
            continue;
          }
          throw e
        }
        if (fd != null) {
          try {
            // get value for the matching key
            const doc = yaml.safeLoad(fs.readFileSync(translationPaths[i], 'utf8'))
            const subKeys = key.substring(semicolonIndex + 1).split('.')
            currentObj = doc
            for (j = 0; j < subKeys.length; j++) {
              if (subKeys[j] in currentObj) {
                currentObj = currentObj[subKeys[j]]
              } else {
                currentObj = null
                break
              }
            }

            if (currentObj != null) {
              return currentObj
            }
          } finally {
            fs.close(fd)
          }
        }
      }
    }
  } catch(e) {
    console.warn(e)
  }

  return defaultValue ? defaultValue : ""
}

function loadPackage(dir) {
  var pjson, doc, module

  fs.readdir(dir, (err, files) => {
    if (err) {
      console.warn(err.message);
      return;
    }

    const packageJsonPath = path.join(dir, "package.json");
    //console.log(packageJsonPath);
    // check if packageJsonPath exists by opening it. fs.exists is deprecated.
    fs.open(packageJsonPath, 'r', (err, fd) => {
      fd && fs.close(fd, (err) => {
        pjson = require(packageJsonPath);
        if (pjson.name == null) {
          console.warn('missing package name');
          return;
        }
        
        if (!checkOS(pjson)) {
          return;
        }

        // cache a package directory path
        packageDirMap[pjson.name] = dir
         
        // load keymap
        const keymapPath = path.join(dir, "keymap.yml");
        fs.open(keymapPath, 'r', (err, fd) => {
          fd && fs.close(fd, (err) => {
            bridge.KeymapManager.load(keymapPath, pjson.name);
          })
        })

        // load menu
        const menuFilePath = path.join(dir, "menu.yml");
        fs.open(menuFilePath, 'r', (err, fd) => {
          fd && fs.close(fd, (err) => {
            bridge.Window.loadMenu(pjson.name, menuFilePath);
          })
        })
          
        // load toolbar
        const toolbarFilePath = path.join(dir, "toolbar.yml");
        fs.open(toolbarFilePath, 'r', (err, fd) => {
          fd && fs.close(fd, (err) => {
            bridge.Window.loadToolbar(pjson.name, toolbarFilePath);
          })
        })

        // load config definition
        const configDefPath = path.join(dir, "config_definition.yml")
        fs.open(configDefPath, 'r', (err, fd) => {
          if (fd) {
            try {
              if (pjson.name != 'default') {
                bridge.ConfigDialog.loadDefinition(pjson.name, configDefPath)
              }
            } catch(e) {
              console.warn(e)
            } finally {
              fs.close(fd)
            }
          }

          // register commands
          if (pjson.main) {
            try {
              module = require(dir)
            } catch(e) {
              console.warn(e)
              return
            }
            if (module.commands) {
              if (pjson.name === 'default') {
                // don't add a package prefix for default package
                for (var prop in module.commands) {
                  if (typeof(prop) === 'string') {
                    commands[prop] = module.commands[prop];
                  } else if (Array.isArray(prop) && prop.length == 2 && typeof(prop[0]) == 'string') {
                    commands[prop[0]] = module.commands[prop];
                  }
                }
                Object.keys(module.commands).forEach((cmd) => {
                  bridge.CommandManager.add(cmd, tr("command." + cmd + ".description"));
                });
              } else {
                for (var prop in module.commands) {
                  commands[pjson.name + '.' + prop] = module.commands[prop];
                }
                Object.keys(module.commands).forEach((cmd) => {
                  bridge.CommandManager.add(pjson.name + '.' + cmd, tr(pjson.name + ":command." + cmd + ".description"));
                });
              }
            } else {
              console.log("no commands")
            }

            // call module's activate method
            if (module.activate) {
              module.activate()
            }
          }
        })
      })
    })
  })
}

// rename QFlags name to enum name (it's impossible to do this in Qt)
const customDialogButtonBox = bridge.DialogButtonBox;
customDialogButtonBox.StandardButton = customDialogButtonBox.StandardButtons;
delete customDialogButtonBox.StandardButtons;

/**
 * @module silkedit
 */
module.exports = {
    // module global functions
    /**
     * アラートを表示する。
     * @param {string} msg - メッセージ
     */
    alert: function(msg) {
      const msgBox = new this.MessageBox;
      msgBox.text = msg;
      msgBox.exec();
    },
    /**
     * ローカライズされた文字列を取得する。
     * @param {string} key - ローカライズされた文字列を探すキー "パッケージ名:キー"のように指定する。
     * @param {string} defaultValue - キーがない場合のデフォルト文字列
     * @returns {string}
     * @example
     * silkedit.tr("hello:hello", "Hello!")
     */
    tr: (key, defaultValue) => tr(key, defaultValue),
    
    // singletons
    App: bridge.App,
    CommandManager: require('./lib/command_manager'),
    Config: bridge.Config,
    Constants: bridge.Constants,
    DocumentManager: bridge.DocumentManager,
    KeymapManager: require('./lib/keymap_manager'),
    ProjectManager: bridge.ProjectManager,
    PackageManager: bridge.PackageManager,
    
    // static classes (expose only static methods. can't new Class)
    Condition: bridge.Condition,

    // classes
    Completer: bridge.Completer,
    Console: bridge.Console,
    Dialog: bridge.Dialog,
    DialogButtonBox: customDialogButtonBox,
    FileDialog: bridge.FileDialog,
    FindReplaceView: bridge.FindReplaceView,
    Font: bridge.Font,
    ItemSelectionModel: bridge.ItemSelectionModel,
    KeyEvent: bridge.KeyEvent,
    Label: bridge.Label,
    LineEdit: bridge.LineEdit,
    MessageBox: bridge.MessageBox,
    Rect: bridge.Rect,
    StringListModel: bridge.StringListModel,
    TextBlock: bridge.TextBlock,
    TextCursor: bridge.TextCursor,
    TextOption: bridge.TextOption,
    TextEditView: bridge.TextEditView,
    Url: bridge.Url,
    VBoxLayout: bridge.VBoxLayout,
    WebView: bridge.WebView,
    Window: bridge.Window,

    // enums
    /**
     * {@link http://doc.qt.io/qt-5/qt.html#CaseSensitivity-enum}
     * @readonly
     * @enum {number}
     * @example
     * silkedit.CaseSensitivity.CaseInsensitive
     */
    CaseSensitivity: bridge.CaseSensitivity,
    Event: bridge.Event,  // expose Event.Type
    /**
     * {@link http://doc.qt.io/qt-5/qt.html#EventPriority-enum}
     * @readonly
     * @enum {number}
     * @example
     * silkedit.EventPriority.NormalEventPriority
     */
    EventPriority: bridge.QtEnums.EventPriority,
    /**
     * {@link http://doc.qt.io/qt-5/qt.html#Key-enum}
     * @readonly
     * @enum {number}
     * @example
     * silkedit.Key.Key_0
     */
    Key: bridge.Key,
    /**
     * {@link http://doc.qt.io/qt-5/qt.html#KeyboardModifier-enum}
     * @readonly
     * @enum {number}
     * @example
     * silkedit.KeyboardModifier.NoModifier
     */
    KeyboardModifier: bridge.QtEnums.KeyboardModifier,
    /**
     * {@link http://doc.qt.io/qt-5/qt.html#Orientation-enum}
     * @readonly
     * @enum {number}
     * @example
     * silkedit.Orientation.Horizontal
     */
    Orientation: bridge.Orientation
};