'use strict';

const os = require('os');
const fs = require('fs-extra');
const path = require('path');
const pkgNameValidate = require("validate-npm-package-name");
const {App, ConditionManager, Dialog, DocumentManager, PackageManager, ProjectManager, TextCursor, TextEdit, Validator, VBoxLayout, Window, tr} = require('silkedit');
const DialogUtils = require('./lib/dialog_utils');
const InputDialog = require('./lib/input_dialog');

// Replace oldexp (string or regexp) in a file content with newStr
function replaceFileContent(file, oldexp, newStr, cb) {
  fs.readFile(file, 'utf-8', (err, data) => {
    if (err) return cb(err)
          
    const result = data.replace(oldexp, newStr)
    fs.writeFile(file, result, 'utf-8', (err) => {
      if (err) return cb(err)
      cb()
    })
  })
}

function move_cursor(operation, repeat) {
  const textEdit = App.activeTextEdit();
  if (textEdit != null) {
    repeat = typeof repeat === 'number' ? repeat : 1;
    const cursor = textEdit.textCursor();
    cursor.movePosition(operation, TextCursor.MoveMode.MoveAnchor, repeat);
    textEdit.setTextCursor(cursor);
  }
}

const popupVisibleCond = {
  value: () => App.activePopupWidget() != null
};

const textEditFocusCond = {
  value: () => {
    return App.focusWidget() instanceof TextEdit;
  }
}

const consoleVisibleCond = {
  value: () => {
    const win = App.activeWindow();
    if (win) {
      const view = win.console();
      if (view) {
        return view.visible;
      }
    }
    return false;
  }
}

const findReplaceViewVisibleCond = {
  value: () => {
    const win = App.activeWindow();
    if (win) {
      const view = win.findReplaceView();
      if (view) {
        return view.visible;
      }
    }
    return false;
  }
}

module.exports = {
  activate: () => {
    ConditionManager.add('console_visible', consoleVisibleCond);
    ConditionManager.add('popup_visible', popupVisibleCond);
    ConditionManager.add('text_edit_focus', textEditFocusCond);
    ConditionManager.add('find_replace_view_visible', findReplaceViewVisibleCond);
  },
  
  deactivate: () => {
    ConditionManager.remove('console_visible');
    ConditionManager.remove('popup_visible');
    ConditionManager.remove('text_edit_focus');
    ConditionManager.remove('find_replace_view_visible');
  },

  commands: {
    "new_file": () => {
      if (Window.windows().length == 0) {
        const win = Window.createWithNewFile();
        if (win == null) {
          console.warn('failed to create a new window');
        } else {
          win.show();
        }

        return;
      }

      let tabView = App.activeTabView();
      if (tabView == null) {
         const group = App.activeTabViewGroup();
         if (group != null) {
           tabView = group.addNewTabView();
         }
      }
      
      if (tabView != null) {
        tabView.addNewTab();
      } else {
        console.log('active tab view is null');
      }
    },
    "new_window": () => {
      const win = Window.createWithNewFile();
      if (win == null) {
        console.warn('failed to create a new window');
      } else {
        win.show();
      }
    },
    "open": () => {
      const paths = DialogUtils.showFileAndDirectoryDialog('Open');
      paths.forEach(function(path) {
        fs.stat(path, (err, stats) => {
          if (err) {
            console.error(err);
            return;
          }
          
          if (stats.isFile()) {
            DocumentManager.open(path);
          } else if (stats.isDirectory()) {
            ProjectManager.open(path);
          } else {
            console.warn(`${path} is neither file nor directory`);
          }
        });
      });
    },
    "open_file": () => {
      const paths = DialogUtils.showFileDialog('Open File')
      paths.forEach(function(path) {
        DocumentManager.open(path)
      })
    },
    "open_folder": () => {
      const paths = DialogUtils.showDirectoryDialog('Open Folder')
      paths.forEach(function(path) {
        ProjectManager.open(path)
      });
    },
    "save": () => {
      const textEdit = App.activeTextEdit()
      if (textEdit != null) {
        textEdit.save()
      }
    },
    "save_as": () => {
      const textEdit = App.activeTextEdit()
      if (textEdit != null) {
        textEdit.saveAs()
      }
    },
    "save_all": () => {
      const tabViewGroup = App.activeTabViewGroup();
      if (tabViewGroup != null) {
        tabViewGroup.tabViews.forEach((tabView) => {
          for (let i = 0; i < tabView.count; i++) {
            const widget = tabView.widget(i);
            if (widget instanceof TextEdit) {
              widget.save();
            }
          }
        });
      }
    },
    "close_all_tabs": () => {
      const tabView = App.activeTabView()
      if (tabView != null) {
        const widgets = [];

        for (let i = 0; i < tabView.count; i++) {
          widgets.push(tabView.widget(i));
        }
        
        for (let i = 0; i < widgets.length; i++) {
          if (!tabView.closeTab(widgets[i])) {
            break;
          }
        }
      }
    },
    "close_other_tabs": (args) => {
      const tabView = App.activeTabView()
      if (tabView != null) {
        const widgets = [];
        const index = 'index' in args ? args.index : tabView.currentIndex;

        for (let i = 0; i < tabView.count; i++) {
          if (i != index) {
            widgets.push(tabView.widget(i));
          }
        }
        
        for (let i = 0; i < widgets.length; i++) {
          if (!tabView.closeTab(widgets[i])) {
            break;
          }
        }
      }
    },
    "close_tab": (args) => {
      const tabView = App.activeTabView()
      if (tabView != null) {
        if (tabView.count > 0) {
          const index = 'index' in args ? args.index : tabView.currentIndex;
          tabView.closeTab(index);
        }
      } else {
        const win = App.activeWindow()
        if (win != null) {
          win.close()
        }
      }
    },
    "close_tabs_to_the_right": (args) => {
      const tabView = App.activeTabView()
      if (tabView != null) {
        const widgets = [];
        const index = 'index' in args ? args.index : tabView.currentIndex;

        for (let i = index + 1; i < tabView.count; i++) {
          widgets.push(tabView.widget(i));
        }
        
        for (let i = 0; i < widgets.length; i++) {
          if (!tabView.closeTab(widgets[i])) {
            break;
          }
        }
      }
    },
    "undo": () => {
      const textEdit = App.activeTextEdit()
      if (textEdit != null) {
        textEdit.undo()
      }
    },
    "redo": () => {
      const textEdit = App.activeTextEdit()
      if (textEdit != null) {
        textEdit.redo()
      }
    },
    "cut": () => {
      const textEdit = App.activeTextEdit()
      if (textEdit != null) {
        textEdit.cut()
      }
    },
    "copy": () => {
      const textEdit = App.activeTextEdit()
      if (textEdit != null) {
        textEdit.copy()
      }
    },
    "paste": () => {
      const textEdit = App.activeTextEdit()
      if (textEdit != null) {
        textEdit.paste()
      }
    },
    "select_all": () => {
      const textEdit = App.activeTextEdit()
      if (textEdit != null) {
        textEdit.selectAll()
      }
    },
    "delete": (args) => {
      const textEdit = App.activeTextEdit()
      if (textEdit != null) {
        const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1
        textEdit.deleteChar(repeat)
      }
    },
    "delete_backward": (args) => {
      const textEdit = App.activeTextEdit()
      if (textEdit != null) {
        const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1
        textEdit.deleteChar(-1 * repeat)
      }
    },
    "move_cursor_up": (args) => {
      const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1;
      move_cursor(TextCursor.MoveOperation.Up, repeat);
    },
    "move_cursor_down": (args) => {
      const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1;
      move_cursor(TextCursor.MoveOperation.Down, repeat);
    },
    "move_cursor_left": (args) => {
      const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1;
      move_cursor(TextCursor.MoveOperation.Left, repeat);
    },
    "move_cursor_right": (args) => {
      const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1;
      move_cursor(TextCursor.MoveOperation.Right, repeat);
    },
    "move_cursor_start_of_line": (args) => {
      const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1;
      move_cursor(TextCursor.MoveOperation.StartOfBlock, repeat);
    },
    "move_cursor_end_of_line": (args) => {
      const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1;
      move_cursor(TextCursor.MoveOperation.EndOfBlock, repeat);
    },
    "find_and_replace": () => {
      const win = App.activeWindow();
      if (win != null) {
        const view = win.findReplaceView();
        if (view != null) {
          view.show();
        }
      }
    },
    "toggle_find_replace_view": () => {
      const win = App.activeWindow();
      if (win != null) {
        const view = win.findReplaceView();
        if (view != null) {
          if (view.visible) {
            view.hide();
          } else {
            view.show();
          }
        }
      }
    },
    "split_horizontally": () => {
      const tabViewGroup = App.activeTabViewGroup()
      if (tabViewGroup != null) {
        tabViewGroup.splitHorizontally();
      }
    },
    "split_vertically": () => {
      const tabViewGroup = App.activeTabViewGroup()
      if (tabViewGroup != null) {
        tabViewGroup.splitVertically();
      }
    },
    "show_scope": () => {
      const win = App.activeWindow()
      const textEdit = App.activeTextEdit()
      if (win != null && textEdit != null) {
        win.statusBar().showMessage(textEdit.scopeName());
      }
    },
    "show_scope_tree": () => {
      const win = App.activeWindow()
      const textEdit = App.activeTextEdit()
      if (win != null && textEdit != null) {
        const dialog = new Dialog;
        dialog.resize(500, 480);
        const layout = new VBoxLayout;
        const view = new TextEdit;
        view.readOnly = true;
        view.showLineNumber = false;
        view.setStyleSheet('');
        view.text = textEdit.scopeTree();
        layout.addWidget(view);
        dialog.setLayout(layout);
        dialog.exec();
      }
    },
    "new_package": () => {
      var validator;
      PackageManager._ensureRootPackageJson();
      const userRootPackageJsonPath = path.join(os.homedir(), '.silk', 'packages', 'package.json');
      const userPackagesNodeModulesPath = path.join(os.homedir(), '.silk', 'packages', 'node_modules');
      fs.readFile(userRootPackageJsonPath, 'utf-8', (err, data) => {
        let rootObj = {};
        if (err) {
          validator = null
        } else {
          rootObj = JSON.parse(data);
          try {
            let pkgnameSet = new Set();
            if ('dependencies' in rootObj) {
              const packages = Object.keys(rootObj['dependencies']);
              pkgnameSet = new Set(packages);
            }
            const validate = (input, pos) => {
              if (input.length == 0 || pkgnameSet.has(input)) {
                return { state: Validator.State.Intermediate };
              }
              
              var result = pkgNameValidate(input);
              
              if (result.validForNewPackages === true) {
                return { state: Validator.State.Acceptable };
              } else {
                return { state: Validator.State.Invalid };
              }
            }
            validator = new Validator(validate);
          } catch(err) {
            console.error(err)
            validator = null
          }
        }

        const dialog = new InputDialog(tr("enter_new_package_name", 'default', "Enter new package name"), "my_package", validator);
        const pkgName = dialog.show();
        // copy hello example package to a new package directory
        if (pkgName == null || pkgName.length == 0) return
        
        const pkgPath = path.join(userPackagesNodeModulesPath, pkgName)
        console.log(pkgPath);
         fs.copy(__dirname + "/resources/hello", pkgPath, (err) => {
           if (err) throw err

           // replace <name> with the new package name
           // open the package dir as project
           const newPkgJsonPath = pkgPath + "/package.json"
           replaceFileContent(newPkgJsonPath, /<name>/g, path.basename(pkgPath), (err) => {
             if (err) throw err
             replaceFileContent(pkgPath + "/menu.yml", /<name>/g, path.basename(pkgPath), (err) => {
               if (err) throw err
               replaceFileContent(pkgPath + "/index.js", /<name>/g, path.basename(pkgPath), (err) => {
                 if (err) throw err
                 replaceFileContent(pkgPath + "/README.md", /<name>/g, path.basename(pkgPath), (err) => {
                  if (err) throw err
                   // append new package's package.json content to packages.json
                   fs.readFile(newPkgJsonPath, (err, data) => {
                    if (err) throw err

                    const newPkgJsonData = JSON.parse(data);
                    const url = newPkgJsonData.repository + "#" + newPkgJsonData.version;
                    if ('dependencies' in rootObj) {
                      rootObj['dependencies'][pkgName] = url;
                    } else {
                      const obj = {};
                      obj[pkgName] = url;
                      rootObj['dependencies'] = obj;
                    }
                    fs.writeFile(userRootPackageJsonPath, JSON.stringify(rootObj), (err) => {
                      if (err) throw err

                      ProjectManager.open(pkgPath);
                      // fixme: package.json is opened in another window (not new window opened above)
                      // ProjectManager.open(path.join(pkgPath, 'package.json'));
                    });
                  });
                 });
               });
             });
           });
         });
      });
    },
    "newline": () => {
      const textEdit = App.activeTextEdit()
      if (textEdit != null) {
        textEdit.insertNewLine()
      }
    },
    "indent": () => {
      const textEdit = App.activeTextEdit();
      if (textEdit != null) {
        textEdit.indent();
      }
    },
    "outdent": () => {
      const textEdit = App.activeTextEdit();
      if (textEdit != null) {
        textEdit.outdent();
      }
    },
    "select_next_tab": () => {
      const tabView = App.activeTabView();
      if (tabView != null) {
        const currentIndex = tabView.currentIndex;
        if (currentIndex + 1 >= tabView.count) {
          tabView.currentIndex = 0;
        } else {
          tabView.currentIndex = currentIndex + 1;
        }
      }
    },
    "select_previous_tab": () => {
      const tabView = App.activeTabView();
      if (tabView != null) {
        const currentIndex = tabView.currentIndex;
        if (currentIndex - 1 < 0) {
          tabView.currentIndex = tabView.count - 1;
        } else {
          tabView.currentIndex = currentIndex - 1;
        }
      }
    },
    "show_console": () => {
      const win = App.activeWindow();
      if (win != null) {
        const view = win.console();
        if (view != null) {
          view.visible = true;
        }
      }
    },
    "hide_console": () => {
      const win = App.activeWindow();
      if (win != null) {
        const view = win.console();
        if (view != null) {
          view.visible = false;
        }
      }
    },
    "find_next": () => {
      const win = App.activeWindow();
      if (win != null) {
        const view = win.findReplaceView();
        if (view != null) {
          view.findNext();
        }
      }
    },
    "find_previous": () => {
      const win = App.activeWindow();
      if (win != null) {
        const view = win.findReplaceView();
        if (view != null) {
          view.findPrevious();
        }
      }
    },
    'reload_packages': () => {
      PackageManager.reloadPackages();
    },
    'close_find_replace_view': () => {
      const win = App.activeWindow();
      if (win != null) {
        const view = win.findReplaceView();
        if (view != null) {
          view.hide();
        }
      }
    },
    'clear_selection': () => {
      const textEdit = App.activeTextEdit();
      if (textEdit != null) {
        const cursor = textEdit.textCursor();
        cursor.clearSelection();
        textEdit.setTextCursor(cursor);
      }
    }
  }
}
