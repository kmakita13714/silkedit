'use strict';

const os = require('os');
const fs = require('fs-extra');
const path = require('path');
const silkedit = require('silkedit');
const DialogUtils = require('./lib/dialog_utils');
const InputDialog = require('./lib/input_dialog');

// Replace oldexp (string or regexp) in a file content with newStr
function replaceFileContent(file, oldexp, newStr, cb) {
	fs.readFile(file, 'utf-8', (err, data) => {
		if (err) return cb(err)
					
		const result = data.replace(oldexp, newStr)
		fs.writeFile(file, result, 'utf-8', (err) => {
			if (err) return cb(err)
			cb()
		})
	})
}

function move_cursor(operation, repeat) {
  const textEdit = silkedit.App.activeTextEdit();
  if (textEdit != null) {
    repeat = typeof repeat === 'number' ? repeat : 1;
    const cursor = textEdit.textCursor();
    cursor.movePosition(operation, silkedit.TextCursor.MoveMode.MoveAnchor, repeat);
    textEdit.setTextCursor(cursor);
  }
}

const popupVisibleCond = {
  value: () => silkedit.App.activePopupWidget() != null
};

const textEditFocusCond = {
  value: () => {
    return silkedit.App.focusWidget() instanceof silkedit.TextEdit;
  }
}

const consoleVisibleCond = {
  value: () => {
    const win = silkedit.App.activeWindow();
    if (win) {
      const view = win.console();
      if (view) {
        return view.visible;
      }
    }
    return false;
  }
}

module.exports = {
	activate: () => {
    silkedit.ConditionManager.add("console_visible", consoleVisibleCond);
    silkedit.ConditionManager.add("popup_visible", popupVisibleCond);
    silkedit.ConditionManager.add("text_edit_focus", textEditFocusCond);
	},
	
	deactivate: () => {
	  silkedit.ConditionManager.remove("console_visible");
    silkedit.ConditionManager.remove("popup_visible");
    silkedit.ConditionManager.remove("text_edit_focus");
	},

	commands: {
		"new_file": () => {
      if (silkedit.Window.windows().length == 0) {
        const win = new silkedit.Window();
        win.activeTabView().addNewTab();
        win.show();
        return;
      }
			const tabView = silkedit.App.activeTabView()
			if (tabView != null) {
				tabView.addNewTab();
			} else {
			  console.log('active tab view is null');
			}
		},
		"open": () => {
			const paths = DialogUtils.showFileAndDirectoryDialog('Open');
			paths.forEach(function(path) {
				fs.stat(path, (err, stats) => {
				  if (err) {
				    console.error(err);
				    return;
				  }
				  
				  if (stats.isFile()) {
				    silkedit.DocumentManager.open(path);
				  } else if (stats.isDirectory()) {
				    silkedit.ProjectManager.open(path);
				  } else {
				    console.warn(`${path} is neither file nor directory`);
				  }
				});
			});
		},
		"open_file": () => {
			const paths = DialogUtils.showFileDialog('Open File')
			paths.forEach(function(path) {
				silkedit.DocumentManager.open(path)
			})
		},
		"open_folder": () => {
			const paths = DialogUtils.showDirectoryDialog('Open Folder')
			paths.forEach(function(path) {
				silkedit.ProjectManager.open(path)
			});
		},
		"save": () => {
			const textEdit = silkedit.App.activeTextEdit()
			if (textEdit != null) {
				textEdit.save()
			}
		},
		"save_as": () => {
			const textEdit = silkedit.App.activeTextEdit()
			if (textEdit != null) {
				textEdit.saveAs()
			}
		},
		"save_all": () => {
			const tabViewGroup = silkedit.App.activeTabViewGroup();
			if (tabViewGroup != null) {
				tabViewGroup.tabViews.forEach((tabView) => {
				  for (let i = 0; i < tabView.count; i++) {
				    const widget = tabView.widget(i);
				    if (widget instanceof silkedit.TextEdit) {
				      widget.save();
				    }
				  }
				});
			}
		},
		"close_all_tabs": () => {
			const tabView = silkedit.App.activeTabView()
			if (tabView != null) {
			  const widgets = [];

  		  for (let i = 0; i < tabView.count; i++) {
		      widgets.push(tabView.widget(i));
  		  }
  		  
        for (let i = 0; i < widgets.length; i++) {
          if (!tabView.closeTab(widgets[i])) {
            break;
          }
        }
			}
		},
		"close_other_tabs": (args) => {
			const tabView = silkedit.App.activeTabView()
			if (tabView != null) {
			  const widgets = [];
  			const index = 'index' in args ? args.index : tabView.currentIndex;

  		  for (let i = 0; i < tabView.count; i++) {
  		    if (i != index) {
  		      widgets.push(tabView.widget(i));
  		    }
  		  }
  		  
        for (let i = 0; i < widgets.length; i++) {
          if (!tabView.closeTab(widgets[i])) {
            break;
          }
        }
			}
		},
		"close_tab": (args) => {
			const tabView = silkedit.App.activeTabView()
			if (tabView != null) {
				if (tabView.count > 0) {
					const index = 'index' in args ? args.index : tabView.currentIndex;
					tabView.closeTab(index);
				} else {
					const win = silkedit.App.activeWindow()
					if (win != null) {
						win.close()
					}
				}
			}
		},
		"close_tabs_to_the_right": (args) => {
			const tabView = silkedit.App.activeTabView()
			if (tabView != null) {
			  const widgets = [];
  			const index = 'index' in args ? args.index : tabView.currentIndex;

  		  for (let i = index + 1; i < tabView.count; i++) {
		      widgets.push(tabView.widget(i));
  		  }
  		  
        for (let i = 0; i < widgets.length; i++) {
          if (!tabView.closeTab(widgets[i])) {
            break;
          }
        }
			}
		},
		"undo": () => {
			const textEdit = silkedit.App.activeTextEdit()
			if (textEdit != null) {
				textEdit.undo()
			}
		},
		"redo": () => {
			const textEdit = silkedit.App.activeTextEdit()
			if (textEdit != null) {
				textEdit.redo()
			}
		},
		"cut": () => {
			const textEdit = silkedit.App.activeTextEdit()
			if (textEdit != null) {
				textEdit.cut()
			}
		},
		"copy": () => {
			const textEdit = silkedit.App.activeTextEdit()
			if (textEdit != null) {
				textEdit.copy()
			}
		},
		"paste": () => {
			const textEdit = silkedit.App.activeTextEdit()
			if (textEdit != null) {
				textEdit.paste()
			}
		},
		"select_all": () => {
			const textEdit = silkedit.App.activeTextEdit()
			if (textEdit != null) {
				textEdit.selectAll()
			}
		},
		"delete": (args) => {
			const textEdit = silkedit.App.activeTextEdit()
			if (textEdit != null) {
				const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1
				textEdit.deleteChar(repeat)
			}
		},
		"delete_backward": (args) => {
			const textEdit = silkedit.App.activeTextEdit()
			if (textEdit != null) {
				const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1
				textEdit.deleteChar(-1 * repeat)
			}
		},
		"move_cursor_up": (args) => {
      const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1;
      move_cursor(silkedit.TextCursor.MoveOperation.Up, repeat);
		},
		"move_cursor_down": (args) => {
      const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1;
      move_cursor(silkedit.TextCursor.MoveOperation.Down, repeat);
		},
		"move_cursor_left": (args) => {
      const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1;
      move_cursor(silkedit.TextCursor.MoveOperation.Left, repeat);
		},
		"move_cursor_right": (args) => {
      const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1;
      move_cursor(silkedit.TextCursor.MoveOperation.Right, repeat);
		},
		"move_cursor_start_of_line": (args) => {
      const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1;
      move_cursor(silkedit.TextCursor.MoveOperation.StartOfBlock, repeat);
		},
    "move_cursor_end_of_line": (args) => {
      const repeat = 'repeat' in args ? Number.parseInt(args.repeat) : 1;
      move_cursor(silkedit.TextCursor.MoveOperation.EndOfBlock, repeat);
		},
		"find_and_replace": () => {
			const win = silkedit.App.activeWindow();
			if (win != null) {
				const view = win.findReplaceView();
				if (view != null) {
				  view.show();
				}
			}
		},
		"split_horizontally": () => {
			const tabViewGroup = silkedit.App.activeTabViewGroup()
			if (tabViewGroup != null) {
				tabViewGroup.splitHorizontally();
			}
		},
		"split_vertically": () => {
			const tabViewGroup = silkedit.App.activeTabViewGroup()
			if (tabViewGroup != null) {
				tabViewGroup.splitVertically();
			}
		},
		"show_scope": () => {
			const win = silkedit.App.activeWindow()
			const textEdit = silkedit.App.activeTextEdit()
			if (win != null && textEdit != null) {
				win.statusBar().showMessage(textEdit.scopeName());
			}
		},
		"show_scope_tree": () => {
			const win = silkedit.App.activeWindow()
			const textEdit = silkedit.App.activeTextEdit()
			if (win != null && textEdit != null) {
			  const dialog = new silkedit.Dialog;
			  dialog.resize(500, 480);
			  const layout = new silkedit.VBoxLayout;
			  const view = new silkedit.TextEdit;
			  view.readOnly = true;
			  view.showLineNumber = false;
			  view.setStyleSheet('');
			  view.text = textEdit.scopeTree();
			  layout.addWidget(view);
			  dialog.setLayout(layout);
			  dialog.exec();
			}
		},
		"new_package": () => {
      var validate;
      silkedit.PackageManager._ensureRootPackageJson();
      const userRootPackageJsonPath = path.join(os.homedir(), '.silk', 'packages', 'package.json');
      const userPackagesNodeModulesPath = path.join(os.homedir(), '.silk', 'packages', 'node_modules');
      fs.readFile(userRootPackageJsonPath, 'utf-8', (err, data) => {
        let rootObj = {};
        if (err) {
          validate = null
        } else {
          rootObj = JSON.parse(data);
          try {
            let pkgnameSet = new Set();
            if ('dependencies' in rootObj) {
              const packages = Object.keys(rootObj['dependencies']);
              pkgnameSet = new Set(packages);
            }
            validate = (pkgName, callback) => {
              callback(!pkgnameSet.has(pkgName))
            }
          } catch(err) {
            console.error(err)
            validate = null
          }
        }

        const dialog = new InputDialog(silkedit.tr("enter_new_package_name", 'default', "Enter new package name"), "my_package", validate);
        const pkgName = dialog.show();
  			// copy hello example package to a new package directory
  			if (pkgName == null || pkgName.length == 0) return
				
  		  const pkgPath = path.join(userPackagesNodeModulesPath, pkgName)
  		  console.log(pkgPath);
   			fs.copy(__dirname + "/resources/hello", pkgPath, (err) => {
   				if (err) throw err

   			  // replace <name> with the new package name
   			  // open the package dir as project
   			  const newPkgJsonPath = pkgPath + "/package.json"
   			  replaceFileContent(newPkgJsonPath, /<name>/g, path.basename(pkgPath), (err) => {
   				  if (err) throw err
   				  replaceFileContent(pkgPath + "/menu.yml", /<name>/g, path.basename(pkgPath), (err) => {
   					  if (err) throw err
   					  replaceFileContent(pkgPath + "/index.js", /<name>/g, path.basename(pkgPath), (err) => {
     					  if (err) throw err
     					  replaceFileContent(pkgPath + "/README.md", /<name>/g, path.basename(pkgPath), (err) => {
      					  if (err) throw err
     					    // append new package's package.json content to packages.json
     					    fs.readFile(newPkgJsonPath, (err, data) => {
    					      if (err) throw err

                    const newPkgJsonData = JSON.parse(data);
                    const url = newPkgJsonData.repository + "#" + newPkgJsonData.version;
                    if ('dependencies' in rootObj) {
                      rootObj['dependencies'][pkgName] = url;
                    } else {
                      const obj = {};
                      obj[pkgName] = url;
                      rootObj['dependencies'] = obj;
                    }
      					    fs.writeFile(userRootPackageJsonPath, JSON.stringify(rootObj), (err) => {
      					      if (err) throw err

        						  silkedit.ProjectManager.open(pkgPath);
        						  // fixme: package.json is opened in another window (not new window opened above)
        						  // silkedit.ProjectManager.open(path.join(pkgPath, 'package.json'));
      					    });
      					  });
   					    });
   					  });
   					});
   				});
   			});
      });
		},
		"newline": () => {
			const textEdit = silkedit.App.activeTextEdit()
			if (textEdit != null) {
				textEdit.insertNewLine()
			}
		},
		"indent": () => {
			const textEdit = silkedit.App.activeTextEdit();
			if (textEdit != null) {
				textEdit.indent();
			}
		},
  	"outdent": () => {
			const textEdit = silkedit.App.activeTextEdit();
			if (textEdit != null) {
				textEdit.outdent();
			}
		},
		"select_next_tab": () => {
			const tabView = silkedit.App.activeTabView();
			if (tabView != null) {
				const currentIndex = tabView.currentIndex;
				if (currentIndex + 1 >= tabView.count) {
					tabView.currentIndex = 0;
				} else {
					tabView.currentIndex = currentIndex + 1;
				}
			}
		},
		"select_previous_tab": () => {
			const tabView = silkedit.App.activeTabView();
			if (tabView != null) {
				const currentIndex = tabView.currentIndex;
				if (currentIndex - 1 < 0) {
					tabView.currentIndex = tabView.count - 1;
				} else {
					tabView.currentIndex = currentIndex - 1;
				}
			}
		},
		"show_console": () => {
      const win = silkedit.App.activeWindow();
      if (win != null) {
        const view = win.console();
        if (view != null) {
          view.visible = true;
        }
      }
		},
		"hide_console": () => {
      const win = silkedit.App.activeWindow();
      if (win != null) {
        const view = win.console();
        if (view != null) {
          view.visible = false;
        }
      }
		},
		"find_next": () => {
		  const win = silkedit.App.activeWindow();
      if (win != null) {
        const view = win.findReplaceView();
        if (view != null) {
          view.findNext();
        }
      }
		},
		"find_previous": () => {
		  const win = silkedit.App.activeWindow();
      if (win != null) {
        const view = win.findReplaceView();
        if (view != null) {
          view.findPrevious();
        }
      }
		},
		'reload_packages': () => {
		  silkedit.PackageManager.reloadPackages();
		}
	}
}
